#!/usr/bin/python3

import pymongo
import re
import os
import json
import shutil
import sys

sys.setrecursionlimit(10000)

PORT=27017
client = pymongo.MongoClient("localhost", PORT)
db = client.cuckoo_db
collection = db.malware_results

required_keys = ["info", "signatures", "target", "debug"]
optional_keys = ["virustotal"]

SCRIPTS_DIR = os.path.dirname(os.path.realpath(__file__))
MAIN_DIR = os.path.join(SCRIPTS_DIR, "..")
FILE_MALWARE_DONE = os.path.join(MAIN_DIR, "results", "malware_done.txt")
FILE_MALWARE_ERROR = os.path.join(MAIN_DIR, "results", "malware_error.txt")
MALWARE_DIR = os.path.join(MAIN_DIR, "shared_with_docker", "malwares")
malware_already_stored = None

def get_json(filename):
    with open(filename) as json_file:
        try:
            return json.load(json_file)
        except Exception as e:
            print(e)
            return {}

def add_js(js):
    try:
        return collection.insert_one(js)
    except Exception as e:
        print(f"Exception with malware {js['malware_name']}")
        print(e)
        return None

def get_errors(js_data):
    errors = js_data["debug"].get("errors", None)
    if errors is None:
        print("There is no 'errors' key in debug.")
        return None
    return errors

def add_to_db(malware_name, monitor_name, js_data):
    errors_during_analysis = get_errors(js_data)
    if errors_during_analysis is None:
        return None
    if len(errors_during_analysis) > 0:
        shutil.copyfile(os.path.join(MALWARE_DIR, "todo", malware_name), 
                        os.path.join(MALWARE_DIR, "with_error", malware_name))
    dic_to_add = {"malware_name": malware_name,
                  "monitor_name": monitor_name}
    for key in required_keys:
        dic_to_add[key] = js_data[key]
    for key in optional_keys:
        data = js_data.get(key, None)
        if data is not None:
            dic_to_add[key] = data
    response = add_js(dic_to_add)
    if isinstance(response, pymongo.results.InsertOneResult):
        add_to_done(dic_to_add)
    return response

def add_to_done(js):
    with open(FILE_MALWARE_DONE, 'a+') as f:
        f.write(f"{js['malware_name']}\t{js['monitor_name']}\n")
    return True

def add_to_error(error, filename=None, malware_name=None, monitor_name=None):
    """
    You must either give filename OR (malware_name AND monitor_name).
    """
    if (monitor_name is None or malware_name is None) and filename is None:
        return False
    if filename is not None:
        monitor_name, malware_name = extract_names(filename=filename)
    if monitor_name is None or malware_name is None:
        return False
    with open(FILE_MALWARE_ERROR, 'a+') as f:
        f.write(f"{malware_name}\t{monitor_name}\t{error}\n")
    return True

def extract_names(js_data=None, filename=None):
    monitor_name, malware_name = None, None
    if js_data is not None:
        monitor_name, malware_name = "", ""
        monitor = js_data["info"].get("monitor", None)
        if monitor is not None:
            monitor_name = monitor.split("/")[-1]
        file_target = js_data["target"].get("file", None)
        if file_target is not None:
            malware_name = file_target["name"]
    if filename is not None:
        in_target = False
        in_info = False
        escape_yara = False
        with open(filename) as f:
            for line in f:
                if malware_name is None:
                    if re.search('"target"', line):
                        in_target = True
                    if in_target and re.search('"yara":', line):
                        escape_yara = True
                    if escape_yara and re.search(']', line):
                        escape_yara = False
                    if in_target and re.search('"name":', line) and not escape_yara:
                        malware_name = line.split('"')[-2]
                        if monitor_name is not None:
                            break
                if monitor_name is None:
                    if re.search('"info"', line):
                        in_info = True
                    if in_info and re.search('"monitor"', line):
                        monitor_name = line.split('"')[-2].split('/')[-1]
                        if malware_name is not None:
                            break
    return monitor_name, malware_name

def fill_malware_already_stored(filename):
    with open(filename) as f:
        for line in f:
            malware_already_stored.append(line.split("\t")[:2])

def already_done(monitor_name, malware_name):
    global malware_already_stored
    if malware_already_stored is None:
        malware_already_stored = []
        fill_malware_already_stored(FILE_MALWARE_DONE)
        fill_malware_already_stored(FILE_MALWARE_ERROR)
    return [malware_name, monitor_name] in malware_already_stored

def add_all_files_to_db():
    """
    This function iterate over all files of a root directory and if the function
    fun applied to the json in the files is true, register the name of the malware
    in a list that is returned
    @param folder: directory name
    @param fun: function
    @return: the list of malware corresponding
    """
    malwares_added = []
    folder = os.path.join(MAIN_DIR, "shared_with_docker", "cuckoo_default", "storage", "analyses")
    for num in os.listdir(folder):
        if "latest" in num or "vmdetect" in num:
            continue
        filename = os.path.join(folder, num, "reports", "report.json")
        try:
            monitor_name, malware_name = extract_names(filename=filename)
        except Exception as e:
            print("Problem with filename: ", e)
            continue
        if already_done(monitor_name, malware_name):
            continue
        js_data = get_json(filename)
        if js_data == {}: # there was a problem with JSonDump Task
            add_to_error("JsonDump error", malware_name=malware_name, monitor_name=monitor_name)
            print(f"Analysis {num} did not produced a good report! (error in JsonDump module)")
            print("The folder won't be erased you can analyze it manually!")
            print()
            continue
        for key in required_keys:
            if key not in js_data.keys():
                print(f"Analysis {num} does not contain required keys!")
                print(js_data.keys())
                break
        else:
            # monitor_name, malware_name = extract_names(js_data=js_data)
            res = add_to_db(malware_name, monitor_name, js_data)
            if isinstance(res, list):
                print("There was some errors during Cuckoo processing task:")
                # todo verify cause of error and do something about it.
                for line in res:
                    if 'Failed to run the processing module "Static"' in line:
                        print(f"The task {num} failed to run the processing module 'Static'.")
                        add_to_error("Static analysis failed", malware_name=malware_name, monitor_name=monitor_name)
                        break
                    if 'Failed to run the processing module "BehaviorAnalysis"' in line:
                        print(f"The task {num} failed to run the processing module 'BehaviorAnalysis'.")
                        add_to_error("Behavior analysis failed", malware_name=malware_name, monitor_name=monitor_name)
                        break
                else:
                    print(f"Unkown error for {num} for {monitor_name} {malware_name}")
                    print(res)
                print()
            elif isinstance(res, pymongo.results.InsertOneResult):
                clean(folder, [num])
                continue
            else:
                print("Unknown return value from insert:")
                print(res)
        print("The folder won't be erased you can analyze it manually!")
        print()
        
    #clean(folder, malwares_added)
    print("Clean done")

def clean(folder, malwares_added):
    for malware in malwares_added:
        shutil.rmtree(os.path.join(folder, malware))

def is_directory_empty(path):
    return len(os.listdir(path)) == 0

if __name__=="__main__":
    add_all_files_to_db()


